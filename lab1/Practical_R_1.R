                  #####  Практика по R №1 #######
#Скаляр - скаляров в R нет.
#Скаляр - это вектор длины 1 
                  #Векторы
#числовые (numeric) 
        # В терминологии R такие данные называются интервальными, 
        # поскольку к ним применимо понятие интервала на числовой прямой. 
        # Целые числа относятся к дискретным интервальным, а числа 
        # с плавающей точкой — к непрерывным интервальным. 
#целые    (integer)                  
#текстовые (character)
#логические (logical)
#факторы (factors) 
# временные ряды (ts) 
# Матрицы (Matrix)
#Таблицы (data.frame) (вытесняется data.table)
#Список (list)
                  
                  #Функции создания векторов
i<-integer(10)
typeof(i)

i<-(10)          #Почуствуйте разницу!
typeof(i)

l<-logical(5)
typeof(l) 

?typeof
help(typeof)


#c(...). Объединяет (конкатенирует) несколько векторов в один.
 c (1, 2, 3)
j<- c ( c (1, 2), 3)
length ( c (1, 2, 3) )
rm(j)
i<-5:100
i[1] #индекс начинается с 1!

typeof(j)
typeof(l)
 #________________________________________________________
#seq(from, to, by = d), seq(from, to, length = n) – Разбивает отрезок 
#[from, to] на части с шагом d, либо на (n - 1) равных частей.

i<-seq (from=0, to=1, by=0.1)
typeof(i)

seq (0, 1, len=5)
seq(2, 20, 2)
c(1:5, 20, 11:15)
c(1:5, seq(10, 20, 2))
#________________________________________________________
#rep(x, times). Конкатенирует times копий вектора x.
rep(c (TRUE , FALSE), 3)
#________________________________________________________
# создаем вектор, выбирая из последователности:
(10: 20) [c(1, 3, 5)]
(10: 20) [-c(1, 3, 5)]
x<-c(1,3,5,7,9)

int_var <- c(1L, 6L, 10L)
typeof(int_var)
int_var <- c(1, 6, 10)
typeof(int_var)

x1 <- 1:10
y<-rep(c(1,5),10)
x1+1
y+2

x1+y #что будет?


#________________________________________________________
#sample(x, n, replace = FALSE, prob = NULL). 
#Создает вектор, являющийся случайной выборкой n значений из вектора x 
#с повторением или без, в зависимости от значения параметра replace. 
#Распределение вероятностей можно задать с помощью параметра prob, 
#по умолчанию все значения равновероятны.
sample(1:20, 5, replace=FALSE)
sample(1:3, 5, replace=TRUE)

x <- sample(c(0,1), 100, replace=T, prob=c(.3,.7)) #что будет?

#######################
#Из дальнейшего изложения находим варианты подсчета нулей и единиц в векторе x
#######################


# Indexing Data in matrix

A=matrix(1:16,4,4)
A
typeof(A)
class(A)

#######################
#Спрогнозируйте результаты:
#######################

A[2,3]
A[1:3,2:4]

A[1,]
A[1:2,]
A[,1:2]
A
A[c(1,3),c(2,4)]

A[-c(1,3),]
A[-c(1,3),-c(1,3,4)]
A[-c(1,3),2]
dim(A)

#_______________________ВВОД С КЛАВИАТУРЫ_________________________________
#Вектор также можно создать также при помощи функции scan(), 
#которая "считывает" последовательно вводимые с клавиатуры значения:
  
x<- scan()
# после каждого нового значения нажать клавишу "Ввод"
# выполнение команды scan завершают введением пустой строки
# программа сообщает о считывании N значений

#____________________________________ИМЕНА_______________________________

#Вы можете именовать вектор 3-мя способами: 
#При создании: 
x <- c(a=1, b=2, c=3);x
#Изменяя существующий вектор: 
x <- 1:3; names(x)<-c("a", "b", "z");x
#или: 
x <- 1:3; names(x)[[1]] <- c("a");x

#Создавая модифицированную копию вектора, вы не обязаны 
#давать уникальные имена 
x <- setNames(1:3, c("a", "b", "a"))
x
#но иметь уникальные названия удобнее
x <- setNames(1:3, c("a", "b", "c"));x

#____________________________________ВЫБОРКИ_______________________________
#генерации выборок реализаций случайных величин, распределенных 
#по определенным законам. 
#в качестве своего первого параметра ФУНКции принимают объем требуемой выборки 
#(размер вектора, получаемого на выходе функции).
x<-rnorm(1:100, mean=0, sd=0.5); x;hist(x) #Выборка из нормального распределения.
y<-runif(1:100, min=0, max=1);y;hist(y) #Выборка из равномерного распределения.
z<-rexp(1:100, rate=1);z;hist(z) #Выборка из экспоненциального распределения.

#________________________________ВЕКТОРНЫЕ ОПЕРАЦИИ_____________________________
#Квадратные скобки указывают на то, что выбирается часть 
#элементов вектора, матрицы или таблицы.
a <- (1:10); a
remove <- c(3,5,7) # удалить 3,5,7-й элементы 
a <- a[-remove];a
a<-a[-c(1,2)];a
a<-a[-length(a)];a

x<--1:8; x
x[c(1,3,4)]
x[c(T,F,F,T,F)]
# !!!!!!!!!!!!!Как найти только элементы вектора с четными индексами?

# Что будет?
#______________
x>5 

sum(x>5) 
sum(x[x>5])
sum(x>5 | x< 3) 
#______________


y<-c(2,3,5,7,11,13);y
y[3]
y[-3];y
X<-c(5,4,11)
y[X]  

#(что такое NA ?)
#______________


#Угадайте разницу между векторами z.1 и z.2. если

z.1<- 1:12*5
z.2<- 1:(12*5)
typeof(z.1)

#Теперь рассмотрим матрицы. Что получится после выполнения команд?
x <-1:12
dim(x)<-c(3,4); x # dim сокращение от dimention 
x[2,3]
print(x[-c(2,3,10)])

m = matrix(1:12, nrow = 3, ncol = 4, byrow = TRUE); m
nrow(m)
ncol(m)

indexes<- which(m == 8, arr.ind = TRUE);indexes
row = indexes[1,1]
col = indexes[1,2]
m[row,col]
m[indexes]

# _________Введите набор  данных_________________________	

z<- c(1, 8, 2, 6, 5, 8, 5, 5, 5, 5)
#zi дальше в задании обозначает i-ыи элемент вектора z.
#Выполните задачи, при дополнительном условии, что 1)zi!=8 2)zi==8 

#1. найдите log10(zi) для каждого i. используйте векторные операции.
#2.	Найдите (zi-1)/2 для каждого i. Используйте векторные операции.
#3.	Найдите (zi-1)%/%2 для каждого i. Используйте векторные операции.
#4.	Найдите размах данных (разность между наибольшим и наименьшим) 
#используйте функции min()  и  max().
#5. Подсчитайте число 8-к и 5-к.

#Почуствуйте разницу!
 z[z!=8];  z[z=8];  z[z==8]; z[which(z==8)]

unique(z)
# или
z[!duplicated(z)]
z[duplicated(z)]
#6. Как определить индексы 8-к и 5-к?

which(z %in% c(5,8))
which.max(z)
which.min(z)
#___________удалить колонку из таблицы__________________________________________
# Создаем таблицу
df = data.frame(c1=1:4, c2=letters[1:4], c3=5:8);df
# Удаляем колонку "с2"
df_new = df[ , -which(names(df) %in% c("c2"))];df_new
df_new1 = df[ ,-2];df_new1
nrow(df_new1) 
ncol(df_new1) 
